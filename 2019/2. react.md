## diff算法
1. 逐级比较（与vue相同）
  - 同层次比较，降低复杂度

2. 列表list
  - 根据key，找到对应关系
  - 然后找到需要更改的元素，且重新渲染
  - key的好处：单独渲染某一个，不会造成整个列表重新渲染

3. 组件
  - 一个应用由许多组件组成
  - 由于组件众多，diff算法会匹配相同类的组件
  - 如果一个组件被另一个组件替换，则会将原组件移除而指向新组件，以此来避免组件的内容diff

4. 事件委托
  - 每个react组件都有一个id来表示它的层级
  - 可以使用简单的字符串操作来所有父节点的id
  - 通过将事件监听器存储在哈希映射中，比直接挂载虚拟DOM上更好

5. 渲染
  - 批量处理
    - setState的异步处理，不会每次setState都渲染，而是批量检查Setstate的值，一次性更新
    - 当数据被setState后，该数据就会被标记为脏值，在事件循环结束时，React会一次性重新渲染所有脏值
  - 子树渲染
    - 在setState的时候，会重新渲染其子组件，即使其没改变
    - 作用：节省diff开销
  - 选择子树渲染
    - 可以选择组件渲染
    - shouldComponentUpdate 生命周期可以让我们自定义选择组件渲染，节省不必要的渲染

---
## setState的异步
1. setState的异步
  - 当数据被setState后，该数据就会被标记为脏值，在事件循环结束时，React会一次性重新渲染所有脏值
2. 需要异步的原因
  - 保证内部数据统一
    - 当父组件props传值给子组件的时候，同时setState改变了值，如果是同步的话则两个组件的值不相等
  - 可以并发更新组件（暂未实现，react以后的计划）
    - 让state的改变进行优先级排序，按照优先级来改变

---
## 生命周期
1. 初始化
  - getDefaultProps：设置默认的props，也可以使用组件的默认属性
  - getInitialState：设置初始化的state，也可以在constructor中进行
  - componentWillMount：组件初始化时调用，绑定state和props；此时可以修改state
  - render：创建虚拟DOM，进行diff算法，更新DOM树，并渲染成真实DOM
  - componentDidMount：虚拟DOM挂载完成后，可操作真实DOM
2. 更新
  - componentWillReceiveProps：收到props的改变时调用，重新绑定props
  - shouldComponentUpdate：默认返回true，可以进行自定义操作
  - componentWillUpdate：state和props改变后调用的，重新绑定state和props
  - render：重新diff，重新渲染DOM
  - componentDidUpdate：渲染完成
3. 销毁
  - componentWillUnmount：销毁之前，清除监听事件和定时器

---
## props触发了哪些生命周期
1. componentWillReceiveProps
2. shouldComponentUpdate
3. componentWillUpdate
4. render
5. componentDidUpdate

---
## component，pureComponent 和 无状态组件


---
## 对于redux的理解


---
## redux的state为什么不能改变


---
## 如何做到局部渲染


---
## react的性能优化


---
## 函数为什么要bind(this)


---
## react-Hook


---
## dva的优缺点


---
## saga的作用