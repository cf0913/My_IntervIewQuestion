## diff算法
1. 逐级比较（与vue相同）
  - 同层次比较，降低复杂度

2. 列表list
  - 根据key，找到对应关系
  - 然后找到需要更改的元素，且重新渲染
  - key的好处：单独渲染某一个，不会造成整个列表重新渲染

3. 组件
  - 一个应用由许多组件组成
  - 由于组件众多，diff算法会匹配相同类的组件
  - 如果一个组件被另一个组件替换，则会将原组件移除而指向新组件，以此来避免组件的内容diff

4. 事件委托
  - 每个react组件都有一个id来表示它的层级
  - 可以使用简单的字符串操作来所有父节点的id
  - 通过将事件监听器存储在哈希映射中，比直接挂载虚拟DOM上更好

5. 渲染
  - 批量处理
    - setState的异步处理，不会每次setState都渲染，而是批量检查Setstate的值，一次性更新
    - 当数据被setState后，该数据就会被标记为脏值，在事件循环结束时，React会一次性重新渲染所有脏值
  - 子树渲染
    - 在setState的时候，会重新渲染其子组件，即使其没改变
    - 作用：节省diff开销
  - 选择子树渲染
    - 可以选择组件渲染
    - shouldComponentUpdate 生命周期可以让我们自定义选择组件渲染，节省不必要的渲染

---
## setState的异步
1. setState的异步
  - 当数据被setState后，该数据就会被标记为脏值，在事件循环结束时，React会一次性重新渲染所有脏值
2. 需要异步的原因
  - 保证内部数据统一
    - 当父组件props传值给子组件的时候，同时setState改变了值，如果是同步的话则两个组件的值不相等
  - 可以并发更新组件（暂未实现，react以后的计划）
    - 让state的改变进行优先级排序，按照优先级来改变

---
## 生命周期
1. 初始化
  - getDefaultProps：设置默认的props，也可以使用组件的默认属性
  - getInitialState：设置初始化的state，也可以在constructor中进行
  - componentWillMount：组件初始化时调用，绑定state和props；此时可以修改state
  - render：创建虚拟DOM，进行diff算法，更新DOM树，并渲染成真实DOM
  - componentDidMount：虚拟DOM挂载完成后，可操作真实DOM
2. 更新
  - componentWillReceiveProps：收到props的改变时调用，重新绑定props
  - shouldComponentUpdate：默认返回true，可以进行自定义操作
  - componentWillUpdate：state和props改变后调用的，重新绑定state和props
  - render：重新diff，重新渲染DOM
  - componentDidUpdate：渲染完成
3. 销毁
  - componentWillUnmount：销毁之前，清除监听事件和定时器

---
## props触发了哪些生命周期
1. componentWillReceiveProps
2. shouldComponentUpdate
3. componentWillUpdate
4. render
5. componentDidUpdate

---
## component，pureComponent 和 无状态组件
1. component
  - ES6的常规方法来继承React的特性
2. pureComponent
  - 基本与Component类似，但是其通过props和state的浅对比来实现shouldComponentUpdate(), 对性能更加友好
  - 只会浅对比，如果是深层次的数据，可能会产生错误的否定判断而没更新组件
  - 所以一般是在简单的props和state的时候使用，或者使用不可变对象，例如immutable.js
3. 无状态组件
  - 无关于性能，是一种架构的选择
  - 使用场景：易复用的简单组件；
  - 无状态组件没有内部状态，所以该组件呈现的内容取决于传入的props
  - 优点
    - 在本身不需要管理任何状态的情况下，无状态组件可以不用管类和继承，纯粹的函数形式
    - 项目中应用无状态组件，视图层以外的逻辑部分全部在redux中，层次分明利于测试
  - 缺点
    - 没有生命周期，只能在层次结构较高的父组件中使用
    - 无法手动控制什么时候需要渲染

---
## 对于redux的理解
1. 整体流程
  - 这个store是由多个reducer合并而成的一个reducer
  - 每个reducer有初始数据和按照方法返回的reducer，以及供组件调用的方法Action
  - 组件调用action，reducer根据antion传递的值进行返回不同的数据给state
2. 三大原则
  - 单一数据源
    - react没有数据向上回溯能力，数据只能单向向下分发
  - state是只读的
    - 原因如下题
  - 状态修改均由纯函数完成
    - 由reducer完成状态修改，每次返回新的state
3. Provider
  - Provider是一个普通组件，可以作为顶层app的分发点，它只需要store属性就可以了。
  - 它会将state分发给所有被connect的组件，不管它在哪里，被嵌套多少层
4. connect
  - 是一个科里化函数，意思是先接受两个参数（数据绑定mapStateToProps和事件绑定mapDispatchToProps），再接受一个参数（将要绑定的组件本身）
  - mapStateToProps：分拣出你需要的Redux状态到需要的组件
  - mapDispatchToProps：声明好的action作为回调，它的参数是dispatch，通过redux的辅助方法bindActionCreator绑定所有action以及参数的dispatch，就可以作为属性在组件里面作为函数简单使用了，不需要手动dispatch

---
## redux的state为什么不能改变
1. redux和react-redux都是使用了浅比较
  - redux的combinaReducers方法是浅比较它调用的reducer的引用是否发生变化
  - react-redux的connect生成的组件都是浅比较根state的变化与mapStateToProps的值来判断是否需要重新渲染
2. 不可变数据提升了数据的安全性
3. 进行时间旅行调试（记录以前的状态）要求reducer是一个没有副作用的纯函数，以此在不同state之间正确的移动

---
## react的性能优化


---
## redux性能优化
1. 拆分reducer
  - 每个action都触发同一个reducer会拖慢redux的性能，且不易维护
2. 减少store更新事件数量
  - 减少订阅者被调用次数

---
## 函数为什么要bind(this)


---
## react-Hook


---
## dva的优缺点


---
## saga的作用