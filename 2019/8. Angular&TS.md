## 依赖注入
1. 定义
  > 将公共依赖的对象的构建方法（构造函数）提取到外层，在各个组件里面直接引入构造函数进行实例化，从而达到依赖的注入
2. 好处
  - 松耦合和解耦性
  - 提高组件可测试性
3. 注入器的层级关系
  - 应用级的注入器：应用创建时，会先创建一个应用级的注入器，将所有的提供器注入到应用级的注入器上
  - 主组件注入器：然后加载主组件注入器
  - 子组件注入器：在组件创建时，父组件的注入器会为每一个子组件创建一个子组件注入器，然后将子组件的提供器注入上去
  - 使用时，从里往外找，所以子组件的层级更高

---
## 数据绑定原理
1. 使用zone.js来监视数据的变更
  - zone.js使用了猴子补丁，将所有的原生事件覆盖，替换成自己的事件，以此达到监听原生事件的目的
2. 与angularJs相比
  - angularJs的脏检查是无法检测原生事件的，需要$apply手动触发
  - zone.js解决了这一点
3. 在zone.js监测到数据变化后
  - ngZone（ng的zoneJs）中的相应的钩子通知angular做相应的脏检查
4. 发布订阅者模式
  - 在检查到数据变化后，触发发布订阅者模式
  - Observer观察者收到Notify通知后，调用update方法对状态进行更新

---
## angular的解析模式
1. 从app.module.ts中开始
2. 注入各种全局依赖module
3. 加载路由和对应component
4. 解析aap.component.ts，开始页面加载

---
## 组件传参
1. 父子组件
  - 父组件通过 `[参数]="值" 或者 (事件)="事件名"` 向子组件传递参数
  - 子组件 `@input` 接收，或者 `@output` 后 emit 给父组件
  - 父组件用子组件方法：直接在引用子组件的时候，`#事件名`在子组件的引用上注册即可使用
2. 兄弟组件
  - 通过中间人模式
3. 路由传参
4. 通过服务传参

---
## 生命周期
1. 初始化阶段
- constructor（只调用一次）
- ngOnChanges
  > 当 Angular（重新）设置数据绑定输入属性时响应
- ngOnInit（只调用一次）
  > 第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。
- ngDoCheck
  > 检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应。
- ngAfterContentInit（只调用一次）
  > 把外部内容投影进组件/指令的视图之后调用。
- ngAfterContentChecked
  > 完成被投影组件内容的变更检测之后调用。
- ngAfterViewInit（只调用一次）
  > 初始化完组件视图及其子视图之后调用。
- ngAfterViewChecked
  > 做完组件视图和子视图的变更检测之后调用。

2. 变更阶段
- ngOnChanges
- ngDoCheck
- ngAfterContentChecked
- ngAfterViewChecked

3. 销毁阶段
- ngOnDestory（只调用一次）

---
## 变更检测机制
1. 原理
  - 由`zone.js`实现的，检测各种异步事件，如click，mouse事件等
  - 当变更检测运行时，会检测组件中所有的绑定关系
  - 变更检测机制只是将组件属性的改变反应到模板上，本身并不会改变组件属性的值
  - 不管变更发生在哪个组件，整个组件树都会被检查一遍

2. onPush策略
  - 阻止检测

3. DoCheck声明周期
  - 每次变更检测时都会调用

---
## 为什么angular第一次打开慢，后面切换快
> 因为app.ts中的module一次性全都注入了，后面无需再次注入