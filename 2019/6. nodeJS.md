## node的特点/优点
1. 单线程
  > 和JS一样是单线程的，不用担心多线程不同步问题
1. 事件驱动，异步编程
  - JS的匿名函数和闭包特性适合做
2. 异步I/O
  > 在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它IO资源的中间层服务
3. 轻量高效
4. 适用场景
  > 适合运用在高并发、I/O密集、少量业务逻辑的场景
5. 缺点
  - 可靠性低，因为JS的语言特性
  - 因为单线程，所以只支持单核CPU，不能利用多核CPU
6. 弥补缺点
  - 可靠性
    - 多用try catch
    - 使用类型判断，弥补JS的弱类型特点
  - 单线程
    - cluster

---
## 单线程
1. 优点
  - 多线程占用的内存高，单线程低
  - 多线程cpu消耗大
  - 多线程内存同步开销大
  - 单线程编写容易

2. 缺点
  - 占用cpu的时间长，无法利用cpu的多核
    - node内置了cluster模块可以利用多核
    - cluster开启多个worker进程，每个worker进程使用children_process.fork()函数使用多核，每个进程之间使用IPC进行通信
  - 单线程抛出异常即停止
    - 通过try catch或自动重启机制

3. 单线程为什么支持高并发
  - V8引擎解析JS代码
  - 解析后调用NodeJs的api
  - libuv库负责api的执行，并将不同的任务分配给不同的线程，形成事件循环队列，并以异步的方式将执行的结果返回给V8

---
## 异步I/O
1. 阻塞
  - 线程在执行中若遇到磁盘读写或网络通信(统称IO操作)耗时较长，此时操作系统会剥夺这个线程的cpu控制权，使其暂停执行，同时让资源让给其他线程，此时为线程阻塞
  - 当IO执行完成后，操作系统解除该线程的阻塞状态，恢复其cpu的控制权

2. 异步I/O 或 非阻塞
  - 当线程遇到I/O操作时，不会阻塞的方式等待I/O执行完成，而是将I/O发送给操作系统，继续执行后面的语句
  - 待操作系统完成I/O操作，以事件的形式通知执行I/O操作的线程，线程会在特定时候处理这个事件

---
## 事件驱动
1. 每个Node程序只有一个主线程在执行代码，形成一个执行栈（context stack）
2. 主线程之外还有一个事件队列，遇到网络请求或其他异步操作，就将此加入到事件队列中，然后主线程继续往下走
3. 主线程执行完后，通过Event Loop按照顺序开始从事件队列中依次取出事件，并从线程池中分配一个线程去执行这个事件
4. 当所有事件执行完成后，通知主线程，主线程执行回调线程归还给线程池
5. 主线程不断重复上述操作

---
## 中间件
1. 定义
  - 通俗来讲类似于插件plugin，用于扩展功能的可安装模块，功能众多，从简单的日志到复杂的协议解析都有
2. 原理
  - 通过express或者koa的app.use方法注入到创建的服务中
  - express是先进先出
  - koa是先进后出

---
## node的事件执行顺序
1. 同步任务；
2. 计时器
3. 微任务
4. I/O
5. Poll
6. check
7. close callBack
8. 在每个阶段执行完后都执行完（清理）一遍微任务队列

---
## express和koa的区别
1. express
  - 主要基于connect中间件
  - 自身封装了路由，视图等功能
  - connect的功能
    - Pre-request：用来改写request的原始数据
    - Request/Response：大部分中间件在此实现
    - Post-Response：全局异常处理，改写response数据

2. koa
  - koa1是基于generator处理异步
  - koa2是基于async await处理异步
  - 保留了express的大部分功能，去除了router，template等功能，体积更小，可以说是基于connect 和 express中间的框架

3. 两者的区别
  - koa体积更小更精简
  - express通过callback控制异步，koa1通过generator，koa2通过async await, 更优雅，没有回调地狱
  - express使用callback捕获异常，koa使用try catch捕获，可以捕获更深层次的异常
  - koa中间件机制是洋葱圈模型，express是先进先出的栈机制

---
## app.use原理
1. 无论是express还是koa，都是通过使用中间件来扩充功能
2. app.use方法就是使用中间件
3. express和koa在创建服务createServer后, 每当use了一个中间件，都将中间件push到一个队列中
4. express：每个请求都将先经过中间件，经过next()后到下个中间件，最后到server中
5. koa2：每个请求都将进入中间件，然后进入下个中间件，先进后出，最后到server中

---
## 如何用node监听80端口
> 因权限问题，监听的端口应大于1024

---
## 运算错误与程序错误的区别
1. 运算错误
  - 请求超时或硬件故障

2. 程序错误
  - 代码写的漏洞

---
## koa原理
1. 原理
  - [文章地址](https://github.com/berwin/Blog/issues/8)
  - ![原理图](https://camo.githubusercontent.com/707ab384df1cffd60ba1c19f188fd6edbce34d3d/687474703a2f2f62657277696e2e6769746875622e696f2f707074732f6b6f612f696d672f6b6f612d666c6f772e6a7067)

2. 语言描述

---
## 怎么处理高并发
1. Node本身自带处理高并发的特点
  > NodeJs的异步I/O自带处理高并发的能力, 将I/O操作交给操作系统，继续执行主进程代码，待操作系统返回结果后再执行I/O的结果

2. 提升
  - nginx做负载均衡，多台NodeJs分摊

---
## node协程
  > 就相当于事件队列，当一个线程受到阻塞后，就切换线程，执行另一个线程的代码，结束后再切换回原线程