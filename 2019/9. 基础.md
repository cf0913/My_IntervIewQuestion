# 基础
1. grid 布局
```css
/* 使用grid布局 */
.layout{
  width: 100%;
  height: 100%;
  overflow: hidden;
  display: grid;
  grid-template-columns: auto 300px;  /* 设置每一列的宽度，第一个是第一列，第二个是第二列 */
  grid-template-rows: auto 100px;   /* 设置每一行的高度，第一个参数是第一行，第二个是第二行 */
}

/* 照片排布 => 自动从左到右排布，且适应大小屏 */
.layout{
  display: grid;
  grid-template-columns: repeat(auto-fill, 100px);    /* 自动填充，每个子元素宽100px, 多了换行 */
}
```

2. css盒模型
  + 基本概念
    - 分为标准模型和IE模型
      - 标准模型：宽高就是实际宽高
      - IE模型：宽高包括border和padding
  + 设置这两个模型
    - `box-sizing: content-box`
    - `box-sizing: border-box`
  + JS如何获取这两种模型的宽高
    - `dom.style.width` 普通
    - `dom.currentStyle.width`  新方法
    - `window.getComputedStyle(dom).width`  兼容firefox
    - `dom.getBlondingClientReact().width`  此方法返回top,left,width,height
  + 解释边距重叠 => 引出BFC

3. DOM事件
  - DOM事件级别
    - DOM0 => element.onclick = () => {}
    - DOM2 => element.addEventListener('click', () => {}, false)
    - DOM3 => element.addEventListener('keyup', () => {}, false)
  - DOM事件模型
    - 就是事件的捕获和冒泡过程
  - 事件流
    - 第一阶段：捕获
    - 第二阶段：目标阶段
    - 第三阶段：冒泡，将事件上传到window对象
  - event.target 和 event.currentTarget
    - target: 当前触发的元素
    - currentTarget: 当前绑定的事件的对象

4. 事件捕获
  - window -> document -> html -> body -> ...
  - 一层一层往下传递，到达目标元素

5. 事件冒泡
  - 从目标元素一层层往上传递，直到window

6. 自定义事件
  - 先创建事件 `var eve = new Event('事件名')`
  - 再使用事件
  - 最后触发事件 `dom.dispatchEvent(eve)`

## AMD和CMD标准



## 节流防抖
1. 函数节流和函数防抖，两者都是优化高频率执行js代码的一种手段
2. 节流
  - 函数节流的要点是，声明一个变量当标志位，记录当前代码是否在执行。
  - 如果空闲，则可以正常触发方法执行。 如果代码正在执行，则取消这次方法执行
  - 节流示例：监听页面滚动
  ```js
    var canRun = true;
    document.getElementById("throttle").onscroll = function(){
      // 判断是否已空闲，如果在执行中，则直接return
      if(!canRun) return
      canRun = false;
      setTimeout(function(){
        console.log("函数节流");
        canRun = true;
      }, 300);
    };
  ```
3. 防抖
  - 函数防抖的应用场景，最常见的就是用户注册时候的手机号码验证和邮箱验证
  - 只有等用户输入完毕后，前端才需要检查格式是否正确
  - 函数防抖的要点，也是需要一个setTimeout来辅助实现。
  - 延迟执行需要跑的代码。如果方法多次触发，则把上次记录的延迟执行代码用clearTimeout清掉，重新开始。
  - 如果计时完毕，没有方法进来访问触发，则执行代码。
  - 防抖示例
  ```js
    var timer = false;
    document.getElementById("debounce").onscroll = function(){
      clearTimeout(timer); // 清除未执行的代码，重置回初始化状态

      timer = setTimeout(function(){
        console.log("函数防抖");
      }, 300);
    }; 
  ```

## 宏任务与微任务



## 事件队列EventLoop