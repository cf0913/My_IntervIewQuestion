# Hot100
#### 1.两数之和 - easy
```js
/*
* 给定一个整数数组 nums 和一个目标值 target，
* 在该数组中找出和为目标值的那两个 整数，并返回他们的数组下标。
* 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍
* 
* 示例：
* 给定 nums = [2, 7, 11, 15], target = 9
* 因为 nums[0] + nums[1] = 2 + 7 = 9
* 所以返回 [0, 1]
*/

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {

};
```
---
#### 2.两数相加 - medium
```js
/*
* 给出两个 非空 的链表用来表示两个非负的整数。
* 其中，它们各自的位数是按照 逆序 的方式存储的，
* 并且它们的每个节点只能存储 一位 数字。
* 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
* 您可以假设除了数字 0 之外，这两个数都不会以 0 开头
* 
* 示例：
* 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
* 输出：7 -> 0 -> 8
* 原因：342 + 465 = 807
*/

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {

};
```
---
#### 3.无重复字符的最长子串 - medium
```js
/*
* 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度
* 
* 示例1:
* 输入: "abcabcbb"
* 输出: 3 
* 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3
* 
* 示例2:
* 输入: "pwwkew"
* 输出: 3
* 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
* 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
*/

/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {

};
```
---
#### 4.寻找两个正序数组的中位数 - hard
```js
/*
* 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。
* 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
* 你可以假设 nums1 和 nums2 不会同时为空。
* 
* 示例1:
* nums1 = [1, 3]
* nums2 = [2]
* 则中位数是 2.0
* 
* 示例2:
* nums1 = [1, 2]
* nums2 = [3, 4]
* 则中位数是 (2 + 3)/2 = 2.5
*/

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
const findMedianSortedArrays = (nums1, nums2) => {
  const len1 = nums1.length;
  const len2 = nums2.length;
  const halfLen = (len1 + len2) / 2;
  const arr = [];
  for (let i1 = 0, i2 = 0; arr.length <= halfLen && (i1 < len1 || i2 < len2);) {
    if (i1 < len1 && i2 < len2) {
      if (nums1[i1] < nums2[i2]) {
        arr.push(nums1[i1++]);
      } else if (nums1[i1] > nums2[i2]) {
        arr.push(nums2[i2++]);
      } else {
        arr.push(nums1[i1++]);
        arr.push(nums2[i2++]);
      }
    } else if (i1 < len1) {
      arr.push(nums1[i1++]);
    } else {
      arr.push(nums2[i2++]);
    }
  }
  if ((len1 + len2) % 2) {
    return arr[halfLen | 0];
  } else {
    return (arr[halfLen - 1] + arr[halfLen]) / 2;
  }
};
```
---
5. 最长回文子串 - medium
```js
/*
* 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000
* 
* 示例1:
* 输入: "babad"
* 输出: "bab"
* 注意: "aba" 也是一个有效答案
* 
* 示例2:
* 输入: "cbbd"
* 输出: "bb"
*/

/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {

};
```
---
6. 正则表达式匹配 - hard
```js
/*
* 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配
* '.' 匹配任意单个字符
* '*' 匹配零个或多个前面的那一个元素
* 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串
* 
* 说明:
* s 可能为空，且只包含从 a-z 的小写字母
* p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *
* 
* 示例1:
* 输入:
* s = "aa"
* p = "a"
* 输出: false
* 解释: "a" 无法匹配 "aa" 整个字符串
* 
* 示例2:
* 输入:
* s = "aa"
* p = "a*"
* 输出: true
* 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 
* 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次
* 
* 示例3:
* 输入:
* s = "ab"
* p = ".*"
* 输出: true
* 解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）
*/

/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {

};
```
---
#### 7.盛最多水的容器 - medium
```js
/*
* 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 
* 在坐标内画 * n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i,  0)
* 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
* 
* 说明：你不能倾斜容器，且 n 的值至少为 2。
* 
* 示例：
* 输入：[1,8,6,2,5,4,8,3,7]
* 输出：49
*/

/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  let res = 0;
  let i = 0;
  let j = height.length - 1;
  while (i < j) {
    let min = Math.min(height[i], height[j]);
    let temp = min * (j - i);
    res = Math.max(res, temp);
    if (height[i] < height[j]) {
      i++;
    } else {
      j--;
    }
  }
  return res;
};
```
---