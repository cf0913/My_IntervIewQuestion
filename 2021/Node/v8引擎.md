# 为什么chrome打开一个tab有4个进程
Chrome浏览器的进程：
1. 1个浏览器进程
  - 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能
2. 多个渲染进程
  - 核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中
  - 默认情况下，Chrome会为每个Tab标签创建一个渲染进程。
  - 出于安全考虑，渲染进程都是运行在沙箱模式下
3. 1个GPU进程
  - Chrome的UI界面都选择采用GPU来绘制
4. 1个网络进程
  - 主要负责页面的网络资源加载
  - 之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程
5. 多个插件进程
  - 主要是负责插件的运行
  - 因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响

多进程缺点：
1. 更高的资源占用
  - 因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境）
2. 更复杂的体系架构
  - 浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了
---

# 垃圾回收：垃圾数据如何自动回收
v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。

新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。

新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：

（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。

（2）如果对象不存活，则释放对象的空间。

（3）最后将 From 空间和 To 空间角色进行交换。

新生代对象晋升到老生代有两个条件：

（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。

老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。

由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。
---

