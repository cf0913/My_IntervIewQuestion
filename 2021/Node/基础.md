# NodeJs基础
#### node的特点/优点
```js
优点：
- 采用事件驱动、异步编程，占用内存少
- 单进程，节约资源
- 异步I/O，提升并发量
- 语言灵活，别人能写的，JavaScript也要能写

缺点：
- 不用编译，可靠性相对较低，一旦出现未捕获的异常将直接导致服务不可用
- 单线程计算能力有限，不能很好的利用多核
- 语言灵活，怎么写的都有
```
---
#### 单线程
```js
主线程是阻塞的，所以说是单线程

其实 nodeJS 有维护一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎

单线程的好处：
    多线程占用内存高
    多线程间切换使得CPU开销大
    多线程由内存同步开销
    编写单线程程序简单
    线程安全
单线程的劣势：
    CPU密集型任务占用CPU时间长（可通过cluster方式解决）
    无法利用CPU的多核（可通过cluster方式解决）
    单线程抛出异常使得程序停止（可通过try catch方式或自动重启机制解决）

node中事件循环的顺序
1. 外部输入数据
2. 轮询阶段（poll）
  - 等待新的I/O事件，node在一些特殊情况下会阻塞在这里
3. 检查阶段(check)
  - setImmediate()的回调会在这个阶段执行
4. 关闭事件回调阶段(close callback)
  - 例如socket.on('close', ...)这种close事件的回调
5. 定时器检查阶段(timer)
  - 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval(）
6. I/O 事件回调阶段(I/O callbacks)
  - 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。
7. 闲置阶段(idle, prepare) 
  - 这个阶段仅在内部使用，可以不必理会

宏任务和微任务
宏任务：
  - setImmediate
  - setTimeout
  - setInterval
  - script（整体代码)
  - I/O 操作等。
微任务：
  - process.nextTick
  - new Promise().then(回调)

Promise.nextTick， setTimeout, setImmediate的使用场景和区别

Promise.nextTick
  - process.nextTick 是一个独立于 eventLoop 的任务队列。
  - 在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。
  - 是所有异步任务中最快执行的。

setTimeout：
  - setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。

setImmediate：
  - setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后

```
---
#### 异步I/O
```js
首先，node的异步I/O不等于非阻塞I/O。非阻塞I/O调用后会虽然也是立即返回，但是应用层会不断的重复I/O操作去轮询系统是否完成数据读取，让CPU处理状态判断，对CPU造成资源的浪费。

然而在异步I/O里，基于多子线程的方式去解决了非阻塞I/O的问题，应用层(主线程)发起I/O请求后，就不再过问情况了。然后让子线程来完成数据获取，当读写完成后通知主线程
```
---
#### 事件驱动
```js
1. Node是一个单线程的语言，采用事件驱动和异步回调的机制。在执行代码的时候，主线程从上往下依次执行，遇到有需要回调的地方，就将此处加入到事件队列中，然后主线程继续往下走，直到运行结束以后，才去执行事件队列中的回调

2. node去执行事件队列中的事件时，如果遇到回调，依然是按照顺序添加进入事件队列，主线程一次往下执行，遇到回调就添加，直至执行完毕。

3. node是一个单线程多进程的。node进程创建一个循环，每个循环就是一个周期，在循环中会从事件队列里查看是否有事件需要处理，如果有就去除事件并执行相关的函数。对于阻塞事件的处理在幕后使用线程池来确保工作的运行，而不占用主循环流程
```
---
#### 中间件
```js
简单来讲，中间件就是一个在一次请求生命周期内执行的函数
每个中间件都可以访问其被附加到的所有路由的 HTTP 请求和响应
另外，中间件可以终止 HTTP 请求，也可以用 next 将其传递给另一个中间件函数
中间件的这种“链”使你可以对代码进行划分并创建可重用的中间件

中间件作用：
    可以将一些信息挂载到请求/响应对象上，供全局访问（全局信息共享）
    做一些全局处理的操作
```
---
#### 运算错误与程序错误的区别
```js
运算错误：系统的问题，例如请求超时或者硬件故障

程序错误：程序的bug
```
---
#### 如何用node监听80端口
```js
非root用户不能监听<1024的端口，这个是内核代码里写着的

且不应该用root用户运行你的程序，这样会有安全问题

非要监听的话，可以改变 capabilities 来达到非root用户也能监控小于1024端口的目的
```
---
#### 怎么处理高并发
```js
1. nodeJS自身特点，可以处理高并发
    由于是异步I/O和事件驱动, 当请求过来后，直接调用子线程发送I/O请求，待请求回来后再触发回调，放进事件队列
2. 服务器负载均衡
```
---
#### require 模块引入的查找方式
```js
当 Node 遇到 require(X) 时，按下面的顺序处理。

（1）如果 X 是内置模块（比如 require('http')）
　　a. 返回该模块。
　　b. 不再继续执行。

（2）如果 X 以 "./" 或者 "/" 或者 "../" 开头
　　a. 根据 X 所在的父模块，确定 X 的绝对路径。
　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。
    X
    X.js
    X.json
    X.node

　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。
    X/package.json（main字段）
    X/index.js
    X/index.json
    X/index.node

（3）如果 X 不带路径
　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。
　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。

（4）抛出 "not found"
```
---
