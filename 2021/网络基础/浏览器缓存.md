# 浏览器缓存
## 1.浏览器本地缓存
```js
Cookie
  - 大小4k（浏览器的限制）
  - 可设置过期时间
  - 可设置domain
  - 随着请求自动携带至请求头
  - 有httpOnly的选项，选中后只能被接口使用
  - 可使用 document.cookie 来操作
  - 字符串存储
  - 一般用来存储token等一些令牌的字段

SessionStroage
  - 大小4M
  - 浏览器关闭即消失
  - 字符串存储
  - 可使用 location.sessionStroage.getItem() 操作

LocalStroage
  - 大小4M
  - 持久存在
  - 字符串存储
  - 可使用 location.sessionStroage.getItem() 操作

```
---
## 1.浏览器缓存1
```js
[参考文献](https://juejin.cn/post/6844903905243955213)
memory cache 内存缓存
  - 内存缓存是一种比较特殊的缓存，他不受max-age、no-cache等配置的影响，即使我们不设置缓存
  - 如果当前的内存空间比较充裕的话，一些资源还是会被缓存下来。
  - 但这种缓存是暂时的，一旦关闭了浏览器，这一部分用于缓存的内存空间就会被释放掉。
  - 如果真的不想使用缓存，可以设置no-store，这样，即便是内存缓存，也不会生效
  - 内存缓存虽然比较高效，但还是受限于计算机内存的大小，所以能让我们使用的内存并不多，这个时候就需要硬盘来存储大量的缓存

disk cache 硬盘缓存
  - Disk Cache 也就是存储在硬盘中的缓存。相比较内存缓存的优势就是长时效。
  - 它会根据HTTP Header中设置的字段类型，来判断资源是否需要重新请求。
  - 如果当前内存使用率高的话，请求资源大概率会被缓存到disk cache。

缓存的过程
  - 浏览器在第一次请求资源后，会获取到请求的结果以及缓存标识，接下来，浏览器会根据第一次请求返回的响应头来确定缓存处理的方式，分别是强缓存和协商缓存。
  - 强缓存
    - 不会向服务器发送请求，直接从缓存中读取资源，强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。
    - 这里我们只强调Cache-Control。Expires已经是比较古老的处理方式，有一定的局限性。
    - 大家在业务中设置缓存策略的时候，直接使用Cache-Control就好
    - Cache-Control
      - 当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存
      - Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用
        - no-cache：
          - 客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。
          - 表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。
          - 这个名字有一点歧义，并不是说浏览器不能缓存，只是浏览器在使用缓存数据时，需要先确认一下资源文件是否还跟服务器保持一致。
        - no-store：
          - 所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存(memory cache也会失效)
        - max-age：
          - max-age=xxx 表示缓存内容将在xxx秒后失效
        - 一般，我们会设置Cache-Control的值为“public, max-age=xxx”，表示在xxx秒内再次访问该资源，均使用本地的缓存，不再向服务器发起请求
      - 强缓存依据某个时间或者某个时间段，所以并不会响应服务端资源文件的变化，一旦资源文件发生了变化，那么强缓存的文件并不会在时间范围之内更改，这样就造成了服务器和浏览器文件不一致的问题，那么怎么解决这个问题呢？此时我们就需要使用协商缓存

  - 协商缓存
    - 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程
    - 协商缓存可以通过设置两种 HTTP Header，Last-Modified或者ETag实现
    - Last-Modified 
      - 是该资源文件最后一次更改时间，服务器会在Response Headers中返回，
      - 浏览器在下一次发送请求时，放到Request Header里的If-Modified-Since里，
      - 服务器在接收到后也会做比对，如果相同则命中协商缓存。
    - Etag
      - 是服务器响应请求时，返回当前资源文件的一个唯一标识，
      - 只要资源有变化，Etag就会重新生成。
      - 浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到Request Header里的If-None-Match里，
      - 服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了
    - Last-Modified返回的最小时间单位是秒，所以，服务器的资源和本地的资源有可能存在不一致，如果请求的时机正好在资源变动的1s之内，ETag使用的是唯一标识，所以能够很好的解决这个问题。

浏览器缓存最佳实践
  频繁变动的资源
    - Cache-Control: no-cache
    - 对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。
    - 这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小
  不常变化的资源
    - Cache-Control: max-age=31536000
    - 通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，
    - 这样浏览器之后请求相同的 URL 会命中强缓存。
    - 而为了解决更新的问题，就需要在文件名中添加 hash，之后更改hash，从而达到更改请求路径的目的
  页面的html应该设置Cache-Control为no-cache，每次请求都去和服务器的文件比对。
  图片，文件之类的可以设置一个长时间的强缓存。更改文件的时候，配合hash值，这样一旦文件发生了改变，那么浏览器直接去请求新的资源，在文件不变动的情况下，直接使用本地缓存，不去向浏览器请求。
```
---
## 2.浏览器缓存2
```js
浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。

web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。

使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。

服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。

Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，
它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间
的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires
来说，这种方式更加有效一些。常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 n
o-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。

一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。

使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。
如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。

服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，
这样会造成缓存命中的不准确。

因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。

当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。

强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。
```
---
## 3. 怎么解决资源的缓存
```
请求URL上带随机数或时间戳
设置请求头 "Cache-Control","no-cache"
设置请求头 "If-Modified-Since","0"
```
---