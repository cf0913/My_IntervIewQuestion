# 浏览器渲染
#### 1.浏览器渲染原理
```js
// 浏览器拿到地址后做些什么
- 识别url
- 访问本地host文件，查找对应域名的ip
- 没找到就向本地 DNS 服务器发起请求
- 由于本地 DNS 服务器没有缓存不能直接将域名转换为 IP 地址，需要采用递归或者迭代查询的方式
- 依次向根域名服务器、顶级域名服务器、权威域名服务器发起查询请求，直至找到一个或一组 IP 地址，返回给浏览器
- 根据找到的IP地址访问对应的服务器，厂商有 DNS 就走 DNS
- 进行三次握手

// 三次握手
第一次握手：客户端发送网络包，服务端收到了，这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。
第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。

关闭连接过程会有四次握手
因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。

// 浏览器拿到静态资源后怎么渲染
- 解析HTML结构
- 加载外部脚本和样式表文件 cssOMTree
- 解析并执行脚本 DOMTree
- DOM树构建完成 RenderTree
- 加载图片等外部资源
- 页面加载完毕

```
---
#### 2.浏览器的垃圾回收机制
```js
v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。

新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。

新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：

（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。

（2）如果对象不存活，则释放对象的空间。

（3）最后将 From 空间和 To 空间角色进行交换。

新生代对象晋升到老生代有两个条件：

（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。

老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。

由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。
```
---
#### 3.如何保证发布新版本后客户端是最新的
```js
- 强缓存 设置 cache-control
- 协商缓存设置过期时间和刷新Etag
- 资源添加hash
- 服务端渲染模板
```
---
#### 4.如何减少首屏白屏时间
```js
- css在顶部，js在底部
- 合理使用loading和骨架屏
- 接口请求不要阻塞页面渲染
- 服务端渲染
```
---
#### 5.重绘重排
```js
- 重绘不一定重排，重排一定重绘
- 什么是重绘/重排
  - 重排：浏览器需要重新计算，并将元素放在其所在的地方，此过程为重排
  - 重绘：当元素的位置和大小等确定以后，浏览器将元素重新绘制一遍，称为重绘
- 什么情况下会造成重绘或重拍
  - css方式
    - 改变颜色或者字体等，会造成重绘
    - 改变position，top，width，height等会造成重排
  - js方式
    - 改变颜色等重绘，同css
    - 操作DOM的位置，如offset, width, height等会造成重排
- 怎么优化重绘重拍
  - css方式
    - 脱离文档流，则重绘重拍都在当前文档流里面
    - display:none; 此时没有渲染，自然没有重绘重排
  - js方式
    - 多次操作放在一起，不要零散的操作DOM和样式
- 框架怎么优化重绘和重拍
  - vue对DOM的操作都是异步的，在多次操作完成后再一次性渲染到页面，节省重绘重拍次数
  - vue的DOM操作是在 vue.$nextTick 队列里面
```
---
