# JS基础
1. 什么是堆？什么是栈？它们之间有什么区别和联系
```js
堆和栈的概念存在于数据结构中和操作系统内存中。
在数据结构中，栈中数据的存取方式为先进后出。
而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。

在操作系统中，内存被分为栈区和堆区
栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈
堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收
```
---
2.this的指向和函数的调用模式
```js
函数调用
  this 指向全局，即 window
方法调用
  this 指向调用这个方法的对象
构造器调用
  this 指向刚 new 出来的对象
上下文调用（自定义this，call， apply）
  this 指向定义的对象
```
---
3.数据类型及判断方法
```js
Number，String，Boolean，Array，Object，undefined，null，Function，Symbol，BigInt

typeof
instanceof  用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
```
---
4.原型链
```js
什么是原型链
  - 实例对象的constructor是一个构造函数
  - 其可以new出一个对象，称为实例
  - 实例可以通过一个非标准属性__proto__访问其原型对象
  - 构造函数的prototype也是指向这个原型对象
  - 原型对象也可以一直访问其原型对象，这就形成了一条链结构
  - 所以，当访问一个对象的属性时，先在其属性上查找，没找到则在其原型对象上查找，依次往下，最终到null

instanceof的原理
  - 例如实例 A
  - A.instanceof 其实就是判断 A 的__proto__的引用地址是不是和 A 的构造函数的引用一致
  - 注意：只要是其原型链上有的，就返回true
  - 所以可以判断是否是Object 或者 Array

new运算符干了什么
  - 创建了一个新对象，其继承了其构造函数的prototype
  - 然后构造函数被执行，this被指定到新实例
  - 如果构造函数本身有返回对象，则new出来的是其返回的结果
  - 如果没有返回，则创建了一个新的对象
```
---
5.对象的深拷贝
```js
- 投机取巧的 JSON.Stringify
- 循环递归，且继承其prototype
- 堆栈方式
- 把对象当作树，遍历树
```
---
6.AMD和CMD标准，CommonJS和ES Module
```js
AMD和CMD标准
  - AMD: 提前执行（异步加载：依赖先执行）+ 延迟执行, 例如 RequireJs
  - CMD: 延迟执行（运行到需加载，根据顺序执行）, 例如 SeaJs
CommonJS
  - 可以写在任何位置
  - 可以使用条件语句
  - 输出的值可以改变
  - 运行时加载，无法静态化
ES Module
  - 通过export命令显式指定输出的代码，再通过import命令输入
  - ES6 模块是编译时加载，使得静态分析成为可能。可以进一步拓宽 JavaScript 的语法
  - 静态化，必须在顶部，不能使用条件语句，自动采用严格模式
  - treeshaking和编译优化，以及webpack3中的作用域提升
  - 外部可以拿到实时值，而非缓存值(是引用而不是copy)
差异
  - CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用
  - CommonJS 模块是运行时加载，ES6 模块是编译时输出接口
  - CommonJS是对模块的浅拷贝，ES6 Module是对模块的引用
  - 可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错
```
---
6.事件冒泡和事件捕获
```js

```
---
---
10.前端路由的实现方式
```js

```
---
