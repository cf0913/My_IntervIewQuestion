1. href 和 src 的区别
```

```
---
2. link 和 @import 引入css的区别
```
从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用, link还可以引入网站图标等其他资源
加载顺序区别。link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载
兼容性区别。@import 是 CSS2.1 才有的语法，link无兼容问题
```
---
3. 浏览器渲染原理
```
- 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的
- 然后对 CSS 进行解析，生成 CSSOM 规则树
- 根据 DOM 树和 CSSOM 规则树构建渲染树.
- 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。
  这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”
- 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件
- 其中JavaScript 的加载、解析与执行会阻塞文档的解析。
  如果在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎
  等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。
```
---
4. async 和 defer 的作用是什么
```
- 脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行
- defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。
  当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成
- async 属性表示异步执行引入的 JavaScript
  与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。
  多个脚本的执行顺序无法保证
```
---
5. 什么是文档的预解析
```
Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。
这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片
```
---
6. 重绘和重排
```
重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，
  比如 background-color，我们将这样的操作称为重绘。
重排: 当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，
  这样的操作我们称为重排。
常见引起重排属性和方法:
  - 添加或者删除可见的 DOM 元素
  - 元素尺寸改变——边距、填充、边框、宽度和高度
  - 内容变化，比如用户在 input 框中输入文字
  - 浏览器窗口尺寸改变——resize事件发生时
  - 计算 offsetWidth 和 offsetHeight 属性
  - 设置 style 属性的值
重排必定会发生重绘，重绘不一定会引发重排。
重排所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列重排。
```
---
7. 如何减少重排
```
- 使用 transform 替代 top
- 不要把节点的属性值放在一个循环里当成循环里的变量
- DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM
- 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className
```
---
8. 为什么操作 DOM 慢
```
一些 DOM 的操作或者属性访问可能会引起页面的重排和重绘，从而引起性能上的消耗
```
---
9. 前端需要注意哪些 SEO
```
- 合理的 title、description、keywords：
- 语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页
- 重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取
- 禁用iframe，爬虫不获取iframe的内容
- js内不渲染内容，因为爬虫爬不到JS里的内容
- 非装饰性图片必须加 alt
- 提高网站速度：网站速度是搜索引擎排序的一个重要指标
```
---
10. cookies，sessionStorage 和 localStorage 的区别
```
浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。

cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服
务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。

sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保
存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源
页面所访问共享。

localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 
不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。

上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏
览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库
```
---
11. 前端性能优化
```
第一个方面是页面的内容方面
  - 通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况
  - 通过 DNS 缓存等机制来减少 DNS 的查询次数。
  - 通过设置缓存策略，对常用不变的资源进行缓存
  - 使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载
  - 通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度
第二个方面是服务器方面
  - 使用 CDN 服务，来提高用户对于资源请求时的响应速度
  - 服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积
  - 尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie
第三个方面是 CSS 和 JavaScript 方面
  - 把样式表放在页面的 head 标签中，减少页面的首次渲染的时间
  - 避免使用 @import 标签
  - 尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染
  - 通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积
  - 对文件分包加载，避免一个文件过大，影响加载速度
第四个方面 提高用户体验
  - 使用骨架屏，减少页面白屏时间和页面抖动
  - 合理的使用loading，不让用户觉得页面没反应
  - 按钮的防抖，防止重复请求
```
---

