# 基础
#### 生命周期
```js
1. 初始化
  - getDefaultProps：设置默认的props，也可以使用组件的默认属性
  - getInitialState：设置初始化的state，也可以在constructor中进行
  - componentWillMount：组件初始化时调用，绑定state和props；此时可以修改state
  - render：创建虚拟DOM，进行diff算法，更新DOM树，并渲染成真实DOM
  - componentDidMount：虚拟DOM挂载完成后，可操作真实DOM
2. 更新
  - componentWillReceiveProps：收到props的改变时调用，重新绑定props
  - shouldComponentUpdate：默认返回true，可以进行自定义操作
  - componentWillUpdate：state和props改变后调用的，重新绑定state和props
  - render：重新diff，重新渲染DOM
  - componentDidUpdate：渲染完成
3. 销毁
  - componentWillUnmount：销毁之前，清除监听事件和定时器
```
---
#### props触发了哪些生命周期(props更新后发生了什么)
```js
1. componentWillReceiveProps
2. shouldComponentUpdate
3. componentWillUpdate
4. render
5. componentDidUpdate
```
---
#### component和pureComponent区别
```js
1. component
  - ES6的常规方法来继承React的特性
2. pureComponent
  - 基本与Component类似，但是其通过props和state的浅对比来实现shouldComponentUpdate(), 对性能更加友好
  - 只会浅对比，如果是深层次的数据，可能会产生错误的否定判断而没更新组件
  - 所以一般是在简单的props和state的时候使用，或者使用不可变对象，例如immutable.js
3. 无状态组件
  - 无关于性能，是一种架构的选择
  - 使用场景：易复用的简单组件；
  - 无状态组件没有内部状态，所以该组件呈现的内容取决于传入的props
  - 优点
    - 在本身不需要管理任何状态的情况下，无状态组件可以不用管类和继承，纯粹的函数形式
    - 项目中应用无状态组件，视图层以外的逻辑部分全部在redux中，层次分明利于测试
  - 缺点
    - 没有生命周期，只能在层次结构较高的父组件中使用
    - 无法手动控制什么时候需要渲染
```
---
#### 为何开头必须引用react
```js
因为jsx只是语法糖，都需要babel转换调用react.createElement方法, 所以必须引入react
```
---
#### react怎么阻止xss攻击
```js
1. 在React.createElement方法在创建虚拟DOM的时候，虚拟DOM的Element（节点）有一个属性 $$typeof
2. $$typeof的值为symbol属性的变量，这个变量可以防止xss
3. 当react判断element不合法时，就会给该element的$$typeof加上symbol值
4. 因为xss一般通过json方式传给后台，json里面不允许存在symbol，所以可以预防xss
```
---
#### 7.react的自定义组件为什么必须首字母大写
```js
React.createElement方法进行创建虚拟DOM的时候，识别第一个参数的首字母，如果是大写的则判断为自定义组件
```
---
